name: workflows-summary

on:
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:
  push:
    branches:
      - new-website
    paths:
      - '.github/workflows/workflows-summary.yml'

jobs:
  aggregate:
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gather workflow run data
        id: gather
        uses: actions/github-script@v7
        with:
          script: |
            const workflows = [
              { id: 'unit-ci.yml', key: 'unit_ci' },
              { id: 'prod-assistant-probe.yml', key: 'probe' },
              { id: 'e2e-prod.yml', key: 'e2e_prod' },
              { id: 'publish-backend.yml', key: 'publish_backend' },
            ];
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function latestRun(wf){
              try {
                const runs = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: wf.id, per_page: 1 });
                if(!runs.data.workflow_runs.length) return { name: wf.id, status: 'absent' };
                const r = runs.data.workflow_runs[0];
                return {
                  name: wf.id,
                  status: r.status,
                  conclusion: r.conclusion,
                  event: r.event,
                  run_started_at: r.run_started_at,
                  updated_at: r.updated_at,
                  html_url: r.html_url,
                  head_branch: r.head_branch,
                  head_sha: r.head_sha,
                };
              } catch (e) {
                core.warning(`Failed to fetch ${wf.id}: ${e.message}`);
                return { name: wf.id, status: 'error', error: e.message };
              }
            }

            const results = {};
            for (const wf of workflows){
              results[wf.key] = await latestRun(wf);
            }

            function overall(results){
              const vals = Object.values(results);
              const failures = vals.filter(v => v.conclusion && v.conclusion !== 'success');
              const missing = vals.filter(v => v.status === 'absent');
              if (failures.length) return 'degraded';
              if (missing.length === vals.length) return 'empty';
              return 'ok';
            }

            const payload = {
              generated_at: new Date().toISOString(),
              overall: overall(results),
              workflows: results,
            };
            // Write file directly here to avoid expression quoting issues
            const fs = require('fs');
            fs.mkdirSync('.github/badges', { recursive: true });
            fs.writeFileSync('.github/badges/workflows.json', JSON.stringify(payload, null, 2));
            core.setOutput('summary_written', 'true');

      - name: Prepare status-badge branch
        run: |
          git fetch origin status-badge:status-badge || echo 'status-badge branch missing'
          git checkout status-badge || git checkout --orphan status-badge
          git reset --soft origin/status-badge || echo 'no remote status-badge yet'

      - name: Show workflows.json
        run: |
          cat .github/badges/workflows.json

      - name: Commit & push
        env:
          GIT_AUTHOR_NAME: github-actions
          GIT_AUTHOR_EMAIL: actions@github.com
          GIT_COMMITTER_NAME: github-actions
          GIT_COMMITTER_EMAIL: actions@github.com
        run: |
          git add .github/badges/workflows.json
          if git diff --cached --quiet; then
            echo 'No changes';
            exit 0
          fi
          git commit -m 'chore(badges): update workflows summary'
          git push origin status-badge

      - name: Summary
        run: |
          echo 'Workflows summary written to status-badge:.github/badges/workflows.json'
