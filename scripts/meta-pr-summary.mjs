#!/usr/bin/env node
/**
 * Build a PR for SiteAgent meta apply:
 * - Picks a slug from --page or finds the newest *.apply.json under agent/artifacts/seo-meta-apply
 * - Optionally creates a ZIP with .diff + .apply.json + .preview.html
 * - Emits outputs: branch, title, commit, body (markdown), html_glob
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

const ROOT = process.cwd();
const REPO = process.env.GITHUB_REPOSITORY || 'OWNER/REPO';
const APPLY_DIR = path.join(ROOT, 'agent', 'artifacts', 'seo-meta-apply');
const PR_DIR = path.join(APPLY_DIR, '_pr');

const args = Object.fromEntries(process.argv.slice(2).map((a, i, arr) => {
  if (!a.startsWith('--')) return [];
  const k = a.slice(2);
  const v = (arr[i + 1] && !arr[i + 1].startsWith('--')) ? arr[i + 1] : '1';
  return [[k, v]];
}).filter(Boolean));

const PAGE = (args.page || '').trim();
const INCLUDE_HTML = ['1','true','TRUE','yes'].includes(String(args['include-html']));
const COMPRESS = ['1','true','TRUE','yes'].includes(String(args.compress));

function out(name, val) {
  console.log(`${name}=${val}`);
  fs.appendFileSync(process.env.GITHUB_OUTPUT || '/dev/null', `${name}=${val}\n`);
}

function slugify(s) {
  return (s || 'page').replace(/^\//,'').toLowerCase().replace(/[^a-z0-9-]+/g,'-').replace(/^-+|-+$/g,'') || 'page';
}

function link(branch, relPath) {
  return `https://github.com/${REPO}/blob/${branch}/${relPath.replace(/\\/g, '/')}`;
}

function newestApply() {
  if (!fs.existsSync(APPLY_DIR)) return null;
  const files = fs.readdirSync(APPLY_DIR).filter(f => f.endsWith('.apply.json'));
  if (!files.length) return null;
  const full = files.map(f => path.join(APPLY_DIR, f));
  full.sort((a,b) => fs.statSync(b).mtimeMs - fs.statSync(a).mtimeMs);
  return full[0];
}

function readApplyJson(p) {
  try { return JSON.parse(fs.readFileSync(p, 'utf-8')); } catch { return null; }
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function listHtmlChanges() {
  // Conservative: stage any html in public/ and dist/ if changed
  const htmlRoots = ['public', 'dist'].map(d => path.join(ROOT, d)).filter(fs.existsSync);
  const globs = [];
  for (const base of htmlRoots) {
    globs.push(`${path.relative(ROOT, base)}/**/*.html`);
  }
  return globs.join('\n');
}

function main() {
  if (!fs.existsSync(APPLY_DIR)) {
    console.error('No apply dir:', APPLY_DIR);
    process.exit(1);
  }

  let slug = PAGE ? slugify(PAGE) : null;
  let applyPath = slug ? path.join(APPLY_DIR, `${slug}.apply.json`) : newestApply();
  if (!applyPath || !fs.existsSync(applyPath)) {
    console.error('No .apply.json found. Provide --page or run preview first.');
    process.exit(1);
  }
  const meta = readApplyJson(applyPath);
  if (!meta) {
    console.error('Invalid apply.json:', applyPath);
    process.exit(1);
  }

  const page = PAGE || meta.path || ('/' + (slug || 'page'));
  slug = slug || slugify(page);

  const diffPath = path.join(APPLY_DIR, `${slug}.diff`);
  const previewPath = path.join(APPLY_DIR, `${slug}.preview.html`);
  const haveDiff = fs.existsSync(diffPath);
  const havePreview = fs.existsSync(previewPath);

  ensureDir(PR_DIR);

  let zipName = `${slug}-${new Date().toISOString().replace(/[:.]/g,'').slice(0,15)}.zip`;
  let zipRel = path.join('agent','artifacts','seo-meta-apply','_pr',zipName);
  if (COMPRESS) {
    const toZip = [applyPath];
    if (haveDiff) toZip.push(diffPath);
    if (havePreview) toZip.push(previewPath);
    const zipAbs = path.join(PR_DIR, zipName);
    // zip -j stores without folder structure
    try {
      execSync(`zip -j "${zipAbs}" ${toZip.map(p => `"${p}"`).join(' ')}`, { stdio: 'inherit' });
    } catch (_err) {
      console.error('Warning: zip command failed, skipping compression');
      zipRel = '';
    }
  } else {
    zipRel = '';
  }

  // Build a friendly PR body
  const bodyMd = [
    `# SiteAgent — SEO Meta PR`,
    ``,
    `**Page:** \`${page}\``,
    `**Artifacts:**`,
    `- \`${path.relative(ROOT, applyPath)}\``,
    haveDiff ? `- \`${path.relative(ROOT, diffPath)}\`` : `- (no diff file)`,
    havePreview ? `- \`${path.relative(ROOT, previewPath)}\`` : `- (no preview file)`,
    zipRel ? `- \`${zipRel}\` (zip)` : ``,
    ``,
    `**Changed:** ${JSON.stringify(meta.changed)}`,
    `**Integrity:** \`${meta.integrity?.algo}:${meta.integrity?.value}\` (${meta.integrity?.size} bytes)`,
    ``,
    `> This PR was generated by the **siteagent-meta-pr** workflow.`
  ].filter(Boolean).join('\n');

  const bodyPath = path.join(PR_DIR, `${slug}-PR.md`);
  fs.writeFileSync(bodyPath, bodyMd, 'utf-8');

  const branch = `meta/${slug}-${new Date().toISOString().replace(/[-:TZ.]/g, '').slice(0,14)}`;
  const title  = `SEO Meta: ${page} — PR-ready diff`;
  const commit = `chore(seo-meta): add PR artifacts for ${page}`;

  // Build comment with proposal and autolinks
  const proposal = meta.proposal || {};
  const diffRel = path.relative(ROOT, diffPath).replace(/\\/g, '/');
  const previewRel = path.relative(ROOT, previewPath).replace(/\\/g, '/');
  const applyRel = path.relative(ROOT, applyPath).replace(/\\/g, '/');

  const comment = [
    `**SEO Meta Proposal for \`${page}\`**`,
    ``,
    `**Title (≤60):** ${proposal.title || '(unchanged)'}`,
    `**Description (≤155):** ${proposal.desc || '(unchanged)'}`,
    ``,
    `**Artifacts:**`,
    haveDiff ? `- Diff: [${diffRel}](${link(branch, diffRel)})` : '',
    havePreview ? `- Preview HTML: [${previewRel}](${link(branch, previewRel)})` : '',
    `- Apply metadata: [${applyRel}](${link(branch, applyRel)})`,
    ``,
    `> Generated by **siteagent-meta-pr** workflow.`
  ].filter(Boolean).join('\n');

  out('branch', branch);
  out('title',  title);
  out('commit', commit);
  out('body',   bodyMd);               // create-pull-request accepts raw body, not only file
  out('html_glob', INCLUDE_HTML ? listHtmlChanges() : '');
  out('apply_path', applyRel);
  out('diff_path', diffRel);
  out('preview_path', previewRel);
  out('comment', comment);
  out('page', page);
}

main();
